# BioSeqIO_Update_Python_3.12

Author: Murat Buyukyoruk

Addition of three new functions to expand the usage of SeqIO package of Biopython with ORF database generated by PRODIGAL.

Prodigal run generates .faa or .fna files that contains the accession of genomes and an ORF identifier (i.e., NZ_CP017479.1_1, NZ_CP017479.1_2, ...). This edited version of the SeqIO package allows to extract ORFs coming from a single genome by using the genome accession (i.e., NZ_CP017479.1).

This package adds three new functions as: 
* **SeqIO.ORF_to_genome()** that edited from the original SeqIO.to_dict()
* **SeqIO.ORF_to_genome_index()** that edited from the original SeqIO.index()
* **SeqIO.ORF_to_genome_index_db()** that edited from the original SeqIO.index_db()

## Setup Steps
___

Setup is easy as changing File.py (in Bio folder) and "__ init__.py" (in SeqIO folder) by copy and pasting these files into the related folders.

### Generate backup files (recommended) and paste replacement files

Before changing any SeqIO package files. First copy original files

    $ python -m inspect -d Bio | grep "Origin" | cut -d" " -f2 | rev | cut -d"/" -f2- | rev # to find installation path of Biopython from command line

Access to the folder, and generate backup file of "File.py"

    $ cd <path_to_Bio_folder>
    $ cp File.py File.py.ori.bak

Once you generated a backup file of the original "File.py" file, copy and paste the "File.py" from this repository.

Change directory to the SeqIO folder and repeat the same steps for the "__ init__.py" file.

    $ cd SeqIO
    $ cp __init__.py __init__.py.ori.bak

Once you generated a backup file of the original "__ init__.py" file, copy and paste the "__ init__.py" from this repository.

## Definitions of functions
___

**def ORF_to_genome(sequences, key_function=None):**

This will allow you to generate dictionary of records that coming from
PRODIGAL ORFs by using the genome accession instead of the whole ORF
accession. This functions is adapted from '.to_dict()' function by changing
the 'if' satatement where it checks if the key is duplicated or not. This
version will convert values in dict to list and if there is a duplicate
accession by genome, it will append the ORF to the same genome accession.
when the genome accession called, it will return all ORFs related to this
accession in a list format.

Arguments:
 - sequences  - An iterator that returns SeqRecord objects,
   or simply a list of SeqRecord objects.
 - key_function - Optional callback function which when given a
   SeqRecord should return a unique key for the dictionary.

e.g. key_function = lambda rec : rec.name
or,  key_function = lambda rec : rec.description.split()[0]

If key_function is omitted then record.id is used, on the assumption
that the records objects returned are SeqRecords with a unique id.

If there are duplicate keys, they will be added to the list under the same
key and calling that accession will return list.

Example usage, defaulting to using the ***record.id.rsplit("_",1)[0]*** as key:

    >>> from Bio import SeqIO
    >>> filename = "input.fasta"
    >>> format = "fasta"
    >>> record_dict = SeqIO.ORF_to_genome(SeqIO.parse(filename, format),key_function=lambda rec : rec.id.rsplit("_",1)[0])
    >>> res = [i.format("fasta") for i in (record_dict['NZ_AP022873.1'])]
    >>> print("".join(res))

    >NZ_AP022873.1_1511 # 1508908 # 1510428 # -1 # ID=1_1511;partial=00;start_type=ATG;rbs_motif=AGGAG;rbs_spacer=5-10bp;gc_cont=0.341
    MSHVQFGDYVMFCNSTGIQTVNLLPILQFQCKQAVIISTDHTEKGLQTQRLMNLLKKNNV
    SAEKIFIDTNEEKNLRDLTNKLIQQAKGYSNIIWNISGGQKIPAAALTTAFQKRITDGFI
    HDIVTYMEAKPPEIWYFGNDYKIHKLRTSVFMSLQDLLNLAGFETVDEDRLYPDPSEDVK
    AKIEIGKRAFEYFRDNELFREAFFNYMKPSELSVRSMVDIKELIKKKLNEVKPEINDLHV
    SKSGYEDMEQKITQIFSRLEKANNKEELKKIIAPLKLIQKPREIYDDYWNSIKKAVIDKV
    LRSIEQDEVKVINSPIDKQQAETLKKQINSIGGIVSYKEGLFFKKDISVFSHFKSNGILF
    EWMVAAAILEEVEKDNRLKDSISEIYHGVKTKNLNSNEKHDAEHDIIIVTKFGTLIIIEL
    KTYEFSGDLVQAQEGLAYKKSGPYGTAIIIGPLLSSMIGKDSKGNKEYPHYIDGPIKSQE
    DTAKQNNTDYYYLDKLHDMLKKKLFI*
    >NZ_AP022873.1_1524 # 1523313 # 1524440 # -1 # ID=1_1524;partial=00;start_type=ATG;rbs_motif=AGGAG;rbs_spacer=5-10bp;gc_cont=0.360
    MSHVHVCLVSEQPIPNLTTVLQFKPDRVVLLKTKEMEEKARFLAEVLKKKQYDVEAELID
    AYDINNVIKVSESLINKCGDCEVSLNITGGTKIGTLGTFQVFYTSGKMIFYVDTKDNKIL
    QLYPENEQKEMPIEVNISIADYLAVYGFQIDTYVKDDSYIYERKELTDYLANTVTSRQHI
    IPAINNALHKYNEKSPLPVSVKLPKDEKLFKLFGLLKGVKQKDGSKIEIHSHNSLMYLKG
    FWFEEYVYMIAKSLNPDDIKLNVKGKWITRGQYHPKNEFDVMLSKKNRLFYISCKTANPD
    RKEEGGEEGVGKEFLYELVSLSDRALGLFGRRMLVSARQVNDPAVRERSKILKVDLVDGK
    NIATLKENLRQWLTE*
    >NZ_AP022873.1_1520 # 1518705 # 1519958 # -1 # ID=1_1520;partial=00;start_type=ATG;rbs_motif=None;rbs_spacer=None;gc_cont=0.364
    MIDNSHDSLFLIVGTNPLPNIVIADYFLKMFSHLREIYLFHSEERQDKNQKGTYSYAQNI
    EHILKARFSKRVLSIHTIPLSDISNAKEIFRDMDKHLRDSLKGDLKIHLNYTGGTKVMVT
    HIYRKVMEYLKERKIKKATSSYLDARTFRIVDDEEGPITSDLRREIKLTLDEIMSLHGFR
    KVNKDEDFRFTEGVKKFKELIEQECLHEFFKRYPRERFLNKKNQLCEKKGEVRDELKSMN
    AEEPFLSVVLALPEDYRIFNPDGSFREPLTNKHLEYALKFIDGRWLEQYVYDILKSHFSD
    LNVYSNYEIRKSDWSGNQKFELDVIVVKGYQLIGISCTTSCERHVCKSKGFEILHRTRQI
    GGDEARTVLITMLNNDKRDELDDELSIDTGGKDNILVLGENDLKQERLVEKIKKFIE*

**def ORF_to_genome_index(filename, format, alphabet=None, key_function=None):**

This will allow you to generate indexed dictionary of records that coming from
PRODIGAL ORFs by using the genome accession instead of the whole ORF
accession. This functions is adapted from '.index()' function by changing
the 'if' satatement where it checks if the key is duplicated or not. This
version will convert values in dict to list and if there is a duplicate
accession by genome, it will append the ORF to the same genome accession.
when the genome accession called, it will return all ORFs related to this
accession in a list format.

Arguments:
 - sequences  - An iterator that returns SeqRecord objects,
   or simply a list of SeqRecord objects.
 - key_function - Optional callback function which when given a
   SeqRecord should return a unique key for the dictionary.

e.g. key_function = lambda rec : rec.name
or,  key_function = lambda rec : rec.description.split()[0]

If key_function is omitted then record.id is used, on the assumption
that the records objects returned are SeqRecords with a unique id.

If there are duplicate keys, they will be added to the list under the same
key and calling that accession will return list.

Example usage, defaulting to using the ***record.id.rsplit("_",1)[0]*** as key:

    >>> from Bio import SeqIO
    >>> filename = "input.fasta"
    >>> format = "fasta"
    >>> record_dict = SeqIO.ORF_to_genome_index(filename, format, key_function=lambda rec : rec.id.rsplit("_",1)[0])
    >>> res = [i.format("fasta") for i in (record_dict['NZ_AP022873.1'])]
    >>> print("".join(res))

    >NZ_AP022873.1_1511 # 1508908 # 1510428 # -1 # ID=1_1511;partial=00;start_type=ATG;rbs_motif=AGGAG;rbs_spacer=5-10bp;gc_cont=0.341
    MSHVQFGDYVMFCNSTGIQTVNLLPILQFQCKQAVIISTDHTEKGLQTQRLMNLLKKNNV
    SAEKIFIDTNEEKNLRDLTNKLIQQAKGYSNIIWNISGGQKIPAAALTTAFQKRITDGFI
    HDIVTYMEAKPPEIWYFGNDYKIHKLRTSVFMSLQDLLNLAGFETVDEDRLYPDPSEDVK
    AKIEIGKRAFEYFRDNELFREAFFNYMKPSELSVRSMVDIKELIKKKLNEVKPEINDLHV
    SKSGYEDMEQKITQIFSRLEKANNKEELKKIIAPLKLIQKPREIYDDYWNSIKKAVIDKV
    LRSIEQDEVKVINSPIDKQQAETLKKQINSIGGIVSYKEGLFFKKDISVFSHFKSNGILF
    EWMVAAAILEEVEKDNRLKDSISEIYHGVKTKNLNSNEKHDAEHDIIIVTKFGTLIIIEL
    KTYEFSGDLVQAQEGLAYKKSGPYGTAIIIGPLLSSMIGKDSKGNKEYPHYIDGPIKSQE
    DTAKQNNTDYYYLDKLHDMLKKKLFI*
    >NZ_AP022873.1_1524 # 1523313 # 1524440 # -1 # ID=1_1524;partial=00;start_type=ATG;rbs_motif=AGGAG;rbs_spacer=5-10bp;gc_cont=0.360
    MSHVHVCLVSEQPIPNLTTVLQFKPDRVVLLKTKEMEEKARFLAEVLKKKQYDVEAELID
    AYDINNVIKVSESLINKCGDCEVSLNITGGTKIGTLGTFQVFYTSGKMIFYVDTKDNKIL
    QLYPENEQKEMPIEVNISIADYLAVYGFQIDTYVKDDSYIYERKELTDYLANTVTSRQHI
    IPAINNALHKYNEKSPLPVSVKLPKDEKLFKLFGLLKGVKQKDGSKIEIHSHNSLMYLKG
    FWFEEYVYMIAKSLNPDDIKLNVKGKWITRGQYHPKNEFDVMLSKKNRLFYISCKTANPD
    RKEEGGEEGVGKEFLYELVSLSDRALGLFGRRMLVSARQVNDPAVRERSKILKVDLVDGK
    NIATLKENLRQWLTE*
    >NZ_AP022873.1_1520 # 1518705 # 1519958 # -1 # ID=1_1520;partial=00;start_type=ATG;rbs_motif=None;rbs_spacer=None;gc_cont=0.364
    MIDNSHDSLFLIVGTNPLPNIVIADYFLKMFSHLREIYLFHSEERQDKNQKGTYSYAQNI
    EHILKARFSKRVLSIHTIPLSDISNAKEIFRDMDKHLRDSLKGDLKIHLNYTGGTKVMVT
    HIYRKVMEYLKERKIKKATSSYLDARTFRIVDDEEGPITSDLRREIKLTLDEIMSLHGFR
    KVNKDEDFRFTEGVKKFKELIEQECLHEFFKRYPRERFLNKKNQLCEKKGEVRDELKSMN
    AEEPFLSVVLALPEDYRIFNPDGSFREPLTNKHLEYALKFIDGRWLEQYVYDILKSHFSD
    LNVYSNYEIRKSDWSGNQKFELDVIVVKGYQLIGISCTTSCERHVCKSKGFEILHRTRQI
    GGDEARTVLITMLNNDKRDELDDELSIDTGGKDNILVLGENDLKQERLVEKIKKFIE*

**def ORF_to_genome_index_db(index_filename, filenames, format, alphabet=None, key_function=None):**

This will allow you to generate index_db SQLite3 dictionary of records that coming from
PRODIGAL ORFs by using the genome accession instead of the whole ORF
accession. This functions is adapted from '.index_db()' function by changing
the 'if' satatement where it checks if the key is duplicated or not. This
version will convert values in dict to list and if there is a duplicate
accession by genome, it will append the ORF to the same genome accession.
when the genome accession called, it will return all ORFs related to this
accession in a list format.

Arguments:
 - sequences  - An iterator that returns SeqRecord objects,
   or simply a list of SeqRecord objects.
 - key_function - Optional callback function which when given a
   SeqRecord should return a unique key for the dictionary.

e.g. key_function = lambda rec : rec.name
or,  key_function = lambda rec : rec.description.split()[0]

If key_function is omitted then record.id is used, on the assumption
that the records objects returned are SeqRecords with a unique id.

If there are duplicate keys, they will be added to the list under the same
key and calling that accession will return list.

Example usage, defaulting to using the record.id.rsplit("_",1)[0] as key:

    >>> from Bio import SeqIO
    >>> filename = "input.fasta"
    >>> format = "fasta"
    >>> record_dict = SeqIO.ORF_to_genome_index_db(filename + ".index",filename, format, key_function=lambda rec : rec.id.rsplit("_",1)[0])
    >>> res = [i.format("fasta") for i in (record_dict['NZ_AP022873.1'])]
    >>> print("".join(res))
    
    >NZ_AP022873.1_1511 # 1508908 # 1510428 # -1 # ID=1_1511;partial=00;start_type=ATG;rbs_motif=AGGAG;rbs_spacer=5-10bp;gc_cont=0.341
    MSHVQFGDYVMFCNSTGIQTVNLLPILQFQCKQAVIISTDHTEKGLQTQRLMNLLKKNNV
    SAEKIFIDTNEEKNLRDLTNKLIQQAKGYSNIIWNISGGQKIPAAALTTAFQKRITDGFI
    HDIVTYMEAKPPEIWYFGNDYKIHKLRTSVFMSLQDLLNLAGFETVDEDRLYPDPSEDVK
    AKIEIGKRAFEYFRDNELFREAFFNYMKPSELSVRSMVDIKELIKKKLNEVKPEINDLHV
    SKSGYEDMEQKITQIFSRLEKANNKEELKKIIAPLKLIQKPREIYDDYWNSIKKAVIDKV
    LRSIEQDEVKVINSPIDKQQAETLKKQINSIGGIVSYKEGLFFKKDISVFSHFKSNGILF
    EWMVAAAILEEVEKDNRLKDSISEIYHGVKTKNLNSNEKHDAEHDIIIVTKFGTLIIIEL
    KTYEFSGDLVQAQEGLAYKKSGPYGTAIIIGPLLSSMIGKDSKGNKEYPHYIDGPIKSQE
    DTAKQNNTDYYYLDKLHDMLKKKLFI*
    >NZ_AP022873.1_1524 # 1523313 # 1524440 # -1 # ID=1_1524;partial=00;start_type=ATG;rbs_motif=AGGAG;rbs_spacer=5-10bp;gc_cont=0.360
    MSHVHVCLVSEQPIPNLTTVLQFKPDRVVLLKTKEMEEKARFLAEVLKKKQYDVEAELID
    AYDINNVIKVSESLINKCGDCEVSLNITGGTKIGTLGTFQVFYTSGKMIFYVDTKDNKIL
    QLYPENEQKEMPIEVNISIADYLAVYGFQIDTYVKDDSYIYERKELTDYLANTVTSRQHI
    IPAINNALHKYNEKSPLPVSVKLPKDEKLFKLFGLLKGVKQKDGSKIEIHSHNSLMYLKG
    FWFEEYVYMIAKSLNPDDIKLNVKGKWITRGQYHPKNEFDVMLSKKNRLFYISCKTANPD
    RKEEGGEEGVGKEFLYELVSLSDRALGLFGRRMLVSARQVNDPAVRERSKILKVDLVDGK
    NIATLKENLRQWLTE*
    >NZ_AP022873.1_1520 # 1518705 # 1519958 # -1 # ID=1_1520;partial=00;start_type=ATG;rbs_motif=None;rbs_spacer=None;gc_cont=0.364
    MIDNSHDSLFLIVGTNPLPNIVIADYFLKMFSHLREIYLFHSEERQDKNQKGTYSYAQNI
    EHILKARFSKRVLSIHTIPLSDISNAKEIFRDMDKHLRDSLKGDLKIHLNYTGGTKVMVT
    HIYRKVMEYLKERKIKKATSSYLDARTFRIVDDEEGPITSDLRREIKLTLDEIMSLHGFR
    KVNKDEDFRFTEGVKKFKELIEQECLHEFFKRYPRERFLNKKNQLCEKKGEVRDELKSMN
    AEEPFLSVVLALPEDYRIFNPDGSFREPLTNKHLEYALKFIDGRWLEQYVYDILKSHFSD
    LNVYSNYEIRKSDWSGNQKFELDVIVVKGYQLIGISCTTSCERHVCKSKGFEILHRTRQI
    GGDEARTVLITMLNNDKRDELDDELSIDTGGKDNILVLGENDLKQERLVEKIKKFIE*





    
